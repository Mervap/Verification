


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > CTLGrammar</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">itmo.verifier.formula</a>
</div>

<h1>Coverage Summary for Class: CTLGrammar (itmo.verifier.formula)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">CTLGrammar</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (39/39)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (52/52)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1556/1556)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CTLGrammar$afOp$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CTLGrammar$agOp$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CTLGrammar$andChain$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (18/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CTLGrammar$auOp$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CTLGrammar$axOp$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CTLGrammar$ctlExpr$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CTLGrammar$efOp$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CTLGrammar$egOp$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CTLGrammar$eqChain$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CTLGrammar$euOp$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CTLGrammar$exOp$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CTLGrammar$implChain$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CTLGrammar$negation$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CTLGrammar$orChain$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$leftAssociative$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$leftAssociative$2</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$leftAssociative$3</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$rightAssociative$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$times$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$times$10</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$times$11</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$times$12</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$times$13</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$times$14</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$times$15</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$times$2</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$times$3</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$times$4</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$times$5</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$times$6</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$times$7</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$times$8</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CTLGrammar$special$$inlined$times$9</td>
    <td class="coverageStat"/>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    94.3%
  </span>
  <span class="absValue">
    (50/53)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    95.5%
  </span>
  <span class="absValue">
    (63/66)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.7%
  </span>
  <span class="absValue">
    (1656/1713)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode"><b class="fc">&nbsp;package itmo.verifier.formula</b>
&nbsp;
&nbsp;import com.github.h0tk3y.betterParse.combinators.*
&nbsp;import com.github.h0tk3y.betterParse.grammar.Grammar
&nbsp;import com.github.h0tk3y.betterParse.grammar.parser
&nbsp;import com.github.h0tk3y.betterParse.lexer.literalToken
&nbsp;import com.github.h0tk3y.betterParse.lexer.regexToken
&nbsp;import com.github.h0tk3y.betterParse.parser.Parser
&nbsp;import itmo.verifier.model.State
&nbsp;import itmo.verifier.model.Variable
&nbsp;import itmo.verifier.visitor.FormulaVisitor
&nbsp;
&nbsp;sealed class CTLFormula {
&nbsp;    abstract fun optimize(): CTLFormula
&nbsp;    abstract fun visit(visitor: FormulaVisitor)
&nbsp;    open fun compute(elements: Map&lt;String, Variable&gt;): Boolean {
&nbsp;        return true
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;object TRUE : CTLFormula() {
&nbsp;    override fun optimize(): CTLFormula {
&nbsp;        return this
&nbsp;    }
&nbsp;
&nbsp;    override fun visit(visitor: FormulaVisitor) {
&nbsp;        if (!visitor.isVisited(this)) {
&nbsp;            for (s in visitor.kripke.states.values) {
&nbsp;                visitor.makeEval(s, this, true)
&nbsp;            }
&nbsp;        }
&nbsp;        return
&nbsp;    }
&nbsp;
&nbsp;    override fun compute(elements: Map&lt;String, Variable&gt;): Boolean {
&nbsp;        return true
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;data class Element(val name: String) : CTLFormula() {
&nbsp;    override fun optimize(): CTLFormula {
&nbsp;        return this
&nbsp;    }
&nbsp;
&nbsp;    override fun visit(visitor: FormulaVisitor) {
&nbsp;        if (visitor.isVisited(this)) return
&nbsp;
&nbsp;        for (s in visitor.kripke.states.values) {
&nbsp;            if (name in s.elements) {
&nbsp;                visitor.makeEval(s, this, true)
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    override fun compute(elements: Map&lt;String, Variable&gt;): Boolean {
&nbsp;        return elements[name]!!.value
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;data class Not(
&nbsp;    val formula: CTLFormula
&nbsp;) : CTLFormula() {
&nbsp;    override fun optimize(): CTLFormula {
&nbsp;        if (formula is Not) {
&nbsp;            return formula.formula.optimize()
&nbsp;        }
&nbsp;        return Not(formula.optimize())
&nbsp;    }
&nbsp;
&nbsp;    override fun visit(visitor: FormulaVisitor) {
&nbsp;        if (!visitor.isVisited(this)) {
&nbsp;            formula.visit(visitor)
&nbsp;            for (s in visitor.kripke.states.values) {
&nbsp;                visitor.makeEval(s, this, !(visitor.getEval(s, formula)))
&nbsp;            }
&nbsp;        }
&nbsp;        return
&nbsp;    }
&nbsp;
&nbsp;    override fun compute(elements: Map&lt;String, Variable&gt;): Boolean {
&nbsp;        return !formula.compute(elements)
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;data class Or(
&nbsp;    val left: CTLFormula,
&nbsp;    val right: CTLFormula
&nbsp;) : CTLFormula() {
&nbsp;    override fun optimize(): CTLFormula {
&nbsp;        return Or(left.optimize(), right.optimize())
&nbsp;    }
&nbsp;
&nbsp;    override fun visit(visitor: FormulaVisitor) {
&nbsp;        if (!visitor.isVisited(this)) {
&nbsp;            left.visit(visitor)
&nbsp;            right.visit(visitor)
&nbsp;            for (s in visitor.kripke.states.values) {
&nbsp;                visitor.makeEval(s, this, visitor.getEval(s, left) || visitor.getEval(s, right))
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    override fun compute(elements: Map&lt;String, Variable&gt;): Boolean {
&nbsp;        return left.compute(elements) || right.compute(elements)
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;data class EX(
&nbsp;    val formula: CTLFormula
&nbsp;) : CTLFormula() {
&nbsp;    override fun optimize(): CTLFormula {
&nbsp;        return EX(formula.optimize())
&nbsp;    }
&nbsp;
&nbsp;    override fun visit(visitor: FormulaVisitor) {
&nbsp;        if (!visitor.isVisited(this)) {
&nbsp;            formula.visit(visitor)
&nbsp;
&nbsp;            for (s in visitor.kripke.states.values) {
&nbsp;                visitor.makeEval(s, this, false)
&nbsp;
&nbsp;                val ts = s.outgoingTransitions
&nbsp;                val transitions = visitor.kripke.transitions
&nbsp;
&nbsp;                val status = ts.any { t -&gt;
&nbsp;                    visitor.getEval(visitor.kripke.states[transitions[t]!!.to]!!, formula)
&nbsp;                }
&nbsp;
&nbsp;                visitor.makeEval(s, this, status)
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;data class AU(
&nbsp;    val left: CTLFormula,
&nbsp;    val right: CTLFormula
&nbsp;) : CTLFormula() {
&nbsp;    override fun optimize(): CTLFormula {
&nbsp;        return AU(left.optimize(), right.optimize())
&nbsp;    }
&nbsp;
&nbsp;    override fun visit(visitor: FormulaVisitor) {
&nbsp;        if (visitor.isVisited(this)) return
&nbsp;
&nbsp;        left.visit(visitor)
&nbsp;        right.visit(visitor)
&nbsp;
&nbsp;        val l = ArrayDeque&lt;State&gt;()
&nbsp;        val nb = mutableMapOf&lt;State, Int&gt;()
&nbsp;        val transitions = visitor.kripke.transitions
&nbsp;
&nbsp;        for (state in visitor.kripke.states.values) {
&nbsp;            val to = transitions.values.filter { it.from == state.id &amp;&amp; (!transitions.containsKey(state.id) &amp;&amp; !visitor.kripke.addedTransitions.contains(it.id) ||
&nbsp;                    transitions.containsKey(state.id))
&nbsp;            }
&nbsp;            nb[state] = to.size
&nbsp;            visitor.makeEval(state, this, false)
&nbsp;
&nbsp;            if (visitor.getEval(state, right)) {
&nbsp;                l += state
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        while (l.isNotEmpty()) {
&nbsp;            val state = l.removeFirst()
&nbsp;
&nbsp;            visitor.makeEval(state, this, true)
&nbsp;
&nbsp;            for (transition in transitions.values) {
&nbsp;                val source = visitor.kripke.states[transition.from]!!
&nbsp;                val destination = visitor.kripke.states[transition.to]!!
&nbsp;
&nbsp;                if (destination === state) {
&nbsp;                    nb[source] = nb[source]!! - 1
&nbsp;
&nbsp;                    if (nb[source] == 0 &amp;&amp; visitor.getEval(source, left) &amp;&amp; !visitor.getEval(source, this)) {
&nbsp;                        l += source
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;data class EU(
&nbsp;    val left: CTLFormula,
&nbsp;    val right: CTLFormula,
&nbsp;) : CTLFormula() {
&nbsp;    override fun optimize(): CTLFormula {
&nbsp;        return EU(left.optimize(), right.optimize())
&nbsp;    }
&nbsp;
&nbsp;    override fun visit(visitor: FormulaVisitor) {
&nbsp;        if (visitor.isVisited(this)) return
&nbsp;
&nbsp;        left.visit(visitor)
&nbsp;        right.visit(visitor)
&nbsp;
&nbsp;        val l = ArrayDeque&lt;State&gt;()
&nbsp;        val seenBefore = mutableMapOf&lt;State, Boolean&gt;()
&nbsp;
&nbsp;        for (state in visitor.kripke.states.values) {
&nbsp;            visitor.makeEval(state, this, false)
&nbsp;            seenBefore[state] = false
&nbsp;
&nbsp;            if (visitor.getEval(state, right)) {
&nbsp;                l += state
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        while (l.isNotEmpty()) {
&nbsp;            val state = l.removeFirst()
&nbsp;
&nbsp;            visitor.makeEval(state, this, true)
&nbsp;
&nbsp;            for (transition in visitor.kripke.transitions.values) {
&nbsp;                val source = visitor.kripke.states[transition.from]!!
&nbsp;                val destination = visitor.kripke.states[transition.to]!!
&nbsp;
&nbsp;                if (destination === state &amp;&amp; seenBefore[source] != true) {
&nbsp;                    seenBefore[source] = true
&nbsp;
&nbsp;                    if (visitor.getEval(source, left)) {
&nbsp;                        l += source
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;
&nbsp;object CTLGrammar : Grammar&lt;CTLFormula&gt;() {
<b class="fc">&nbsp;    val tr by literalToken(&quot;1&quot;)</b>
<b class="fc">&nbsp;    val fal by literalToken(&quot;0&quot;)</b>
<b class="fc">&nbsp;    val lpar by literalToken(&quot;(&quot;)</b>
<b class="fc">&nbsp;    val rpar by literalToken(&quot;)&quot;)</b>
<b class="fc">&nbsp;    val lspar by literalToken(&quot;[&quot;)</b>
<b class="fc">&nbsp;    val rspar by literalToken(&quot;]&quot;)</b>
<b class="fc">&nbsp;    val not by literalToken(&quot;!&quot;)</b>
<b class="fc">&nbsp;    val and by literalToken(&quot;&amp;&amp;&quot;)</b>
<b class="fc">&nbsp;    val or by literalToken(&quot;||&quot;)</b>
<b class="fc">&nbsp;    val impl by literalToken(&quot;-&gt;&quot;)</b>
<b class="fc">&nbsp;    val eq by literalToken(&quot;==&quot;)</b>
<b class="fc">&nbsp;    val comma by literalToken(&quot;,&quot;)</b>
<b class="fc">&nbsp;    val ax by regexToken(&quot;AX\\b&quot;)</b>
<b class="fc">&nbsp;    val ex by regexToken(&quot;EX\\b&quot;)</b>
<b class="fc">&nbsp;    val af by regexToken(&quot;AF\\b&quot;)</b>
<b class="fc">&nbsp;    val ef by regexToken(&quot;EF\\b&quot;)</b>
<b class="fc">&nbsp;    val ag by regexToken(&quot;AG\\b&quot;)</b>
<b class="fc">&nbsp;    val eg by regexToken(&quot;EG\\b&quot;)</b>
<b class="fc">&nbsp;    val au by regexToken(&quot;AU\\b&quot;)</b>
<b class="fc">&nbsp;    val eu by regexToken(&quot;EU\\b&quot;)</b>
<b class="fc">&nbsp;    val name by regexToken(&quot;\\w+&quot;)</b>
<b class="fc">&nbsp;    val ws by regexToken(&quot;\\s+&quot;, ignore = true)</b>
&nbsp;
<b class="fc">&nbsp;    val negation by -not * parser(this::ctlExpr) map { Not(it) }</b>
<b class="fc">&nbsp;    val bracedExpression by -lpar * parser(this::implChain) * -rpar</b>
&nbsp;
&nbsp;
<b class="pc">&nbsp;    val axOp by -ax * parser(this::bracedExpression) map { f -&gt; Not(EX(Not(f))) }</b>
<b class="fc">&nbsp;    val exOp by -ex * parser(this::bracedExpression) map { f -&gt; EX(f) }</b>
<b class="fc">&nbsp;    val afOp by -af * parser(this::bracedExpression) map { f -&gt; AU(TRUE, f) }</b>
<b class="fc">&nbsp;    val efOp by -ef * parser(this::bracedExpression) map { f -&gt; EU(TRUE, f) }</b>
<b class="fc">&nbsp;    val agOp by -ag * parser(this::bracedExpression) map { f -&gt; Not(EU(TRUE, Not(f))) }</b>
<b class="fc">&nbsp;    val egOp by -eg * parser(this::bracedExpression) map { f -&gt; Not(AU(TRUE, Not(f))) }</b>
<b class="fc">&nbsp;    val auOp by -au * -lspar * parser(this::ctlExpr) * -comma * parser(this::ctlExpr) * -rspar map { (a, b) -&gt; AU(a, b) }</b>
<b class="pc">&nbsp;    val euOp by -eu * -lspar * parser(this::ctlExpr) * -comma * parser(this::ctlExpr) * -rspar map { (a, b) -&gt; EU(a, b) }</b>
&nbsp;
&nbsp;
&nbsp;
<b class="fc">&nbsp;    val ctlExpr: Parser&lt;CTLFormula&gt; by</b>
<b class="fc">&nbsp;            (tr asJust TRUE) or</b>
<b class="fc">&nbsp;            (fal asJust Not(TRUE)) or</b>
<b class="fc">&nbsp;            (name map { Element(it.text) }) or</b>
<b class="fc">&nbsp;            negation or</b>
<b class="fc">&nbsp;            bracedExpression or</b>
<b class="fc">&nbsp;            axOp or</b>
<b class="fc">&nbsp;            exOp or</b>
<b class="fc">&nbsp;            afOp or</b>
<b class="fc">&nbsp;            efOp or</b>
<b class="fc">&nbsp;            agOp or</b>
<b class="fc">&nbsp;            egOp or</b>
<b class="fc">&nbsp;            auOp or</b>
<b class="fc">&nbsp;            euOp</b>
&nbsp;
<b class="pc">&nbsp;    val eqChain by leftAssociative(ctlExpr, eq) { a, _, b -&gt; Or(Not(Or(a, b)), Not(Or(Not(a), Not(b)))) }</b>
<b class="fc">&nbsp;    val andChain by leftAssociative(eqChain, and) { a, _, b -&gt; Not(Or(Not(a), Not(b))) }</b>
<b class="fc">&nbsp;    val orChain by leftAssociative(andChain, or) { a, _, b -&gt; Or(a, b) }</b>
<b class="fc">&nbsp;    val implChain by rightAssociative(orChain, impl) { a, _, b -&gt; Or(Not(a), b) }</b>
&nbsp;
&nbsp;
<b class="fc">&nbsp;    override val rootParser by implChain</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-01-25 13:00</div>
</div>
</body>
</html>
